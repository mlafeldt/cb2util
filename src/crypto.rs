//! Cryptographic functions for CodeBreaker PS2 files
//!
//! This module handles file-level encryption (RC4) and RSA signature verification.
//! Code-level encryption is handled by the `codebreaker` crate.

use num_bigint::BigUint;
use sha1::{Digest, Sha1};

/// 1024-byte ARCFOUR key for file encryption/decryption
static FILE_KEY: [u8; 1024] = [
    0x2B, 0xF3, 0x2C, 0x6A, 0x73, 0x33, 0xCC, 0xD6, 0x01, 0x8F, 0x28, 0x26, 0xF0, 0xD6, 0xAF, 0xBF,
    0xEB, 0x7C, 0xCF, 0x96, 0xAD, 0x40, 0x35, 0x16, 0xB1, 0x84, 0x8D, 0x29, 0x08, 0x86, 0x78, 0xE5,
    0x06, 0x86, 0x7D, 0xCC, 0xA5, 0x45, 0x9D, 0x26, 0xB5, 0x0E, 0x97, 0x87, 0xCB, 0x45, 0xEA, 0x61,
    0xC0, 0xC2, 0x13, 0xEB, 0x44, 0x34, 0xB8, 0xB7, 0x17, 0xFB, 0x2A, 0x06, 0xB4, 0x19, 0xB3, 0xAD,
    0x3F, 0x98, 0xEB, 0xCC, 0xF1, 0x21, 0xB5, 0x89, 0x82, 0x37, 0x52, 0xAF, 0x19, 0xF6, 0xF9, 0x55,
    0x25, 0x2E, 0xF0, 0x6B, 0xB2, 0x7A, 0x37, 0x24, 0xDA, 0x0F, 0xA6, 0x50, 0x9E, 0xF0, 0x13, 0x66,
    0xB9, 0x60, 0xB7, 0x31, 0x3D, 0x9F, 0x89, 0xE3, 0x10, 0x40, 0x04, 0xEA, 0x73, 0x87, 0x33, 0x5D,
    0xFA, 0xA8, 0x47, 0x6B, 0x5B, 0xF2, 0x7D, 0x64, 0x04, 0x2E, 0x82, 0x4E, 0x1C, 0x19, 0x7E, 0x42,
    0xC6, 0xE0, 0x0D, 0x5E, 0x1D, 0x2C, 0xBD, 0x39, 0xD5, 0x13, 0x5D, 0x3F, 0x58, 0xF1, 0x7C, 0xA1,
    0x27, 0x44, 0xE6, 0xD6, 0x34, 0xF3, 0x9F, 0x8D, 0x61, 0x12, 0x78, 0xFA, 0xD8, 0x3C, 0x04, 0xA8,
    0x50, 0x09, 0xEE, 0x59, 0xEC, 0x5A, 0xD4, 0x4F, 0xFB, 0x2B, 0xB4, 0xD5, 0xBE, 0x4E, 0xD2, 0x8D,
    0xD6, 0x07, 0x26, 0xAC, 0x24, 0x11, 0x1D, 0x5B, 0x7C, 0xD4, 0xEC, 0xD4, 0x1D, 0xBE, 0xB1, 0x6E,
    0x72, 0x93, 0x0E, 0x37, 0xCE, 0x97, 0xCD, 0x8D, 0xAA, 0xB4, 0xAA, 0x48, 0x0D, 0xED, 0xB2, 0x94,
    0x25, 0xDF, 0x70, 0x1E, 0xB2, 0x34, 0xFE, 0xDF, 0x2E, 0xF7, 0x8D, 0x4C, 0x08, 0x6F, 0xE0, 0xE8,
    // The rest contains ASCII text (copyright notice) embedded in the key
    0x43, 0x6F, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x32, 0x30, 0x30, 0x33, 0x20, 0xA9,
    0x20, 0x50, 0x65, 0x6C, 0x69, 0x63, 0x61, 0x6E, 0x20, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x6F,
    0x72, 0x69, 0x65, 0x73, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x2C, 0x20, 0x43, 0x4D, 0x47, 0x53,
    0x43, 0x43, 0x43, 0x2E, 0x63, 0x6F, 0x6D, 0x20, 0x26, 0x20, 0x53, 0x6D, 0x69, 0x6C, 0x65, 0x79,
    0x0D, 0x0A, 0x0D, 0x0A, 0x20, 0x20, 0x41, 0x20, 0x42, 0x49, 0x47, 0x20, 0x73, 0x68, 0x6F, 0x75,
    0x74, 0x6F, 0x75, 0x74, 0x20, 0x28, 0x2F, 0x73, 0x61, 0x72, 0x63, 0x61, 0x73, 0x6D, 0x29, 0x20,
    0x67, 0x6F, 0x65, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x6C, 0x6F, 0x73, 0x65, 0x72, 0x73, 0x20, 0x77, 0x68, 0x6F, 0x20, 0x73, 0x65, 0x74, 0x20, 0x75,
    0x73, 0x0D, 0x0A, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x39, 0x20, 0x6D, 0x6F, 0x6E, 0x74, 0x68, 0x73,
    0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6B, 0x69, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73,
    0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x65, 0x61, 0x74, 0x20, 0x6D,
    0x61, 0x72, 0x6B, 0x65, 0x74, 0x20, 0x28, 0x79, 0x6F, 0x75, 0x20, 0x6B, 0x6E, 0x6F, 0x77, 0x20,
    0x77, 0x68, 0x6F, 0x0D, 0x0A, 0x79, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x29, 0x2E, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x73, 0x61, 0x64, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20,
    0x79, 0x6F, 0x75, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x65, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x6E, 0x6F, 0x77, 0x20, 0x66, 0x75, 0x6C, 0x6C,
    0x20, 0x73, 0x74, 0x65, 0x61, 0x6D, 0x0D, 0x0A, 0x61, 0x68, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x72,
    0x65, 0x61, 0x64, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x6B, 0x69, 0x63, 0x6B, 0x20, 0x61, 0x73, 0x73,
    0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x73, 0x20,
    0x6C, 0x61, 0x74, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x61,
    0x6B, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x6F, 0x0D, 0x0A, 0x70, 0x72, 0x69, 0x73, 0x6F, 0x6E, 0x65,
    0x72, 0x73, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x70, 0x61, 0x72, 0x65, 0x20, 0x74,
    0x6F, 0x20, 0x64, 0x69, 0x65, 0x20, 0x73, 0x6C, 0x6F, 0x77, 0x2E, 0x20, 0x57, 0x65, 0x20, 0x61,
    0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x70, 0x75, 0x74, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x66,
    0x69, 0x73, 0x68, 0x20, 0x64, 0x65, 0x61, 0x64, 0x0D, 0x0A, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x77, 0x61, 0x74, 0x65, 0x72, 0x2C, 0x20, 0x77, 0x68, 0x6F, 0x73, 0x20, 0x6E, 0x65, 0x78,
    0x74, 0x3F, 0x0D, 0x0A, 0x20, 0x2D, 0x43, 0x4D, 0x58, 0x0D, 0x0A, 0x0D, 0x0A, 0x20, 0x20, 0x20,
    0x20, 0x41, 0x20, 0x77, 0x69, 0x73, 0x65, 0x6D, 0x61, 0x6E, 0x20, 0x6F, 0x6E, 0x63, 0x65, 0x20,
    0x73, 0x61, 0x69, 0x64, 0x3A, 0x0D, 0x0A, 0x0D, 0x0A, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68,
    0x65, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x61, 0x63,
    0x65, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x72, 0x65, 0x20, 0x77, 0x65, 0x20, 0x61, 0x6C, 0x6C,
    0x20, 0x6A, 0x75, 0x73, 0x74, 0x0D, 0x0A, 0x68, 0x65, 0x61, 0x64, 0x65, 0x64, 0x20, 0x66, 0x6F,
    0x72, 0x20, 0x0D, 0x64, 0x6F, 0x6F, 0x6D, 0x2C, 0x20, 0x73, 0x74, 0x69, 0x6C, 0x6C, 0x20, 0x63,
    0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62,
    0x65, 0x61, 0x73, 0x74, 0x0D, 0x0A, 0x41, 0x6E, 0x64, 0x20, 0x49, 0x20, 0x6B, 0x6E, 0x6F, 0x77,
    0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x27, 0x6C, 0x6C, 0x20, 0x6E, 0x65, 0x76, 0x65,
    0x72, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x61, 0x63, 0x65, 0x0D, 0x0A, 0x54, 0x68, 0x61, 0x74,
    0x27, 0x73, 0x20, 0x77, 0x68, 0x79, 0x20, 0x49, 0x20, 0x6B, 0x65, 0x65, 0x70, 0x20, 0x6D, 0x79,
    0x20, 0x70, 0x69, 0x73, 0x74, 0x6F, 0x6C, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x49, 0x20, 0x77,
    0x61, 0x6C, 0x6B, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x65, 0x74, 0x73, 0x0D,
    0x0A, 0x43, 0x61, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x75,
    0x6C, 0x64, 0x20, 0x6E, 0x65, 0x76, 0x65, 0x72, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65, 0x61, 0x63,
    0x65, 0x0D, 0x0A, 0x0D, 0x0A, 0x28, 0x54, 0x68, 0x65, 0x20, 0x76, 0x69, 0x65, 0x77, 0x73, 0x20,
    0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x62, 0x6F, 0x76, 0x65, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x6F, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x43, 0x4D, 0x58,
    0x20, 0x61, 0x6E, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x69, 0x65,
    0x77, 0x73, 0x20, 0x6F, 0x66, 0x0D, 0x0A, 0x50, 0x65, 0x6C, 0x69, 0x63, 0x61, 0x6E, 0x20, 0x41,
    0x63, 0x63, 0x65, 0x73, 0x73, 0x6F, 0x72, 0x69, 0x65, 0x73, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E,
    0x20, 0x6F, 0x72, 0x20, 0x77, 0x77, 0x77, 0x2E, 0x63, 0x6F, 0x64, 0x65, 0x62, 0x72, 0x65, 0x61,
    0x6B, 0x65, 0x72, 0x2E, 0x63, 0x6F, 0x6D, 0x29, 0x0A, 0x00, 0x00, 0x00, 0xBE, 0xEF, 0xBE, 0xEF,
];

/// RSA public exponent (17 bits)
const RSA_FILE_EXP: u32 = 65537;

/// RSA public modulus (2048 bits) for signature verification
static RSA_FILE_MOD: [u8; 256] = [
    0x27, 0x54, 0xE0, 0x35, 0x17, 0x15, 0xC3, 0xAB, 0x20, 0x95, 0x2D, 0x6F, 0xBE, 0x52, 0x13, 0x9E,
    0xFC, 0x8D, 0x04, 0x5A, 0x70, 0x46, 0x70, 0x5C, 0xBB, 0x73, 0xD3, 0x83, 0x08, 0x97, 0x80, 0x68,
    0xEC, 0x30, 0x12, 0x09, 0xB8, 0x1C, 0x21, 0xE1, 0x76, 0xFE, 0xE5, 0xE3, 0xFB, 0xE2, 0x6C, 0x8A,
    0xFB, 0x04, 0x57, 0x46, 0x2C, 0xD6, 0x93, 0x74, 0x68, 0x78, 0xF8, 0x30, 0x4C, 0x78, 0x0A, 0xDA,
    0x16, 0x4B, 0x03, 0xC1, 0xA5, 0xF4, 0x85, 0x09, 0x75, 0x84, 0x90, 0x77, 0xAB, 0xAC, 0x60, 0xB8,
    0x21, 0xB6, 0xD9, 0x6E, 0x98, 0x3C, 0x9A, 0xC1, 0xFB, 0x50, 0x75, 0x58, 0xFE, 0x15, 0xEF, 0x01,
    0x82, 0xC7, 0x95, 0x33, 0x55, 0x95, 0x81, 0x4A, 0xCF, 0x21, 0x1A, 0x1F, 0x2E, 0x87, 0xA9, 0xEF,
    0xEC, 0xED, 0x98, 0x64, 0x42, 0xEC, 0xBB, 0xC9, 0xC6, 0xDB, 0x9E, 0x5E, 0x19, 0x32, 0x25, 0xDC,
    0xD6, 0xEC, 0x85, 0x1E, 0x89, 0x7C, 0x88, 0x08, 0xCA, 0xA5, 0xCB, 0x91, 0x11, 0x1D, 0xF7, 0x99,
    0x0A, 0xD8, 0xAE, 0xB5, 0xD7, 0x7B, 0x2C, 0x80, 0xB0, 0xA5, 0xB4, 0x02, 0xC4, 0xB6, 0x19, 0xAF,
    0x23, 0xDB, 0xEC, 0x77, 0x16, 0xE9, 0xD8, 0x4B, 0x28, 0xEC, 0x27, 0x42, 0x8A, 0x45, 0xDE, 0x03,
    0x12, 0xFF, 0x98, 0xEA, 0x3D, 0xE9, 0x1A, 0x46, 0x28, 0x20, 0x37, 0xCA, 0xD5, 0x05, 0x99, 0xCB,
    0x80, 0x10, 0xB1, 0xEB, 0x7E, 0x15, 0x2B, 0x64, 0xE6, 0x14, 0x7F, 0xB8, 0x95, 0xB4, 0xCF, 0x3C,
    0x75, 0xCA, 0x90, 0x7E, 0x60, 0xC6, 0x81, 0xD2, 0x01, 0x7B, 0x43, 0xCC, 0xFB, 0x04, 0xB7, 0x8D,
    0x96, 0x04, 0x81, 0x36, 0xE7, 0x94, 0x8A, 0x67, 0x60, 0x3B, 0xF2, 0x4B, 0x7E, 0xE0, 0xF6, 0x1A,
    0xF6, 0x65, 0x47, 0x10, 0x12, 0x5C, 0x64, 0x47, 0xFB, 0x17, 0xD9, 0x5E, 0x83, 0x67, 0x11, 0x90,
];

/// ARCFOUR (RC4) context
struct Rc4 {
    perm: [u8; 256],
    index1: u8,
    index2: u8,
}

impl Rc4 {
    /// Initialize RC4 with a key
    fn new(key: &[u8]) -> Self {
        let mut perm = [0u8; 256];
        for (i, p) in perm.iter_mut().enumerate() {
            *p = i as u8;
        }

        let mut j: u8 = 0;
        for i in 0..256 {
            j = j.wrapping_add(perm[i]).wrapping_add(key[i % key.len()]);
            perm.swap(i, j as usize);
        }

        Self {
            perm,
            index1: 0,
            index2: 0,
        }
    }

    /// Encrypt/decrypt data in place
    fn crypt(&mut self, buf: &mut [u8]) {
        for byte in buf.iter_mut() {
            self.index1 = self.index1.wrapping_add(1);
            self.index2 = self.index2.wrapping_add(self.perm[self.index1 as usize]);
            self.perm.swap(self.index1 as usize, self.index2 as usize);

            let j = self.perm[self.index1 as usize].wrapping_add(self.perm[self.index2 as usize]);
            *byte ^= self.perm[j as usize];
        }
    }
}

/// Encrypt or decrypt CodeBreaker file data using RC4
pub fn crypt_data(buf: &mut [u8]) {
    let mut rc4 = Rc4::new(&FILE_KEY);
    rc4.crypt(buf);
}

/// Verify RSA signature on CodeBreaker files (CBC v8+ and PCB)
///
/// Returns true if signature is valid, false otherwise.
pub fn verify_signature(sig: &[u8; 256], data: &[u8]) -> bool {
    // Convert signature to BigUint (little-endian)
    let sig_int = BigUint::from_bytes_le(sig);
    let exp = BigUint::from(RSA_FILE_EXP);
    let modulus = BigUint::from_bytes_le(&RSA_FILE_MOD);

    // Decrypt signature: m = c^e mod n
    let decrypted = sig_int.modpow(&exp, &modulus);

    // Calculate SHA-1 hash of data
    let mut hasher = Sha1::new();
    hasher.update(data);
    let hash = hasher.finalize();

    // The SHA-1 hash is in big-endian, but the C code stores the digest
    // as native-endian u32 words. Convert the hash to little-endian words.
    let mut hash_le = [0u8; 20];
    for i in 0..5 {
        let be_word = u32::from_be_bytes([
            hash[i * 4],
            hash[i * 4 + 1],
            hash[i * 4 + 2],
            hash[i * 4 + 3],
        ]);
        hash_le[i * 4..i * 4 + 4].copy_from_slice(&be_word.to_le_bytes());
    }

    // Compare decrypted signature with hash (first 20 bytes)
    let decrypted_bytes = decrypted.to_bytes_le();

    // Hash is 20 bytes, check if decrypted matches
    if decrypted_bytes.len() < 20 {
        // Pad with zeros if needed
        let mut padded = [0u8; 20];
        padded[..decrypted_bytes.len()].copy_from_slice(&decrypted_bytes);
        padded[..] == hash_le[..]
    } else {
        decrypted_bytes[..20] == hash_le[..]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rc4_roundtrip() {
        let original = b"Hello, CodeBreaker!";
        let mut data = original.to_vec();

        crypt_data(&mut data);
        assert_ne!(&data, original);

        crypt_data(&mut data);
        assert_eq!(&data, original);
    }
}
